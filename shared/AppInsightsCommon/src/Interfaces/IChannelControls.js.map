{"version":3,"file":"IChannelControls.js","sourceRoot":"","sources":["IChannelControls.ts"],"names":[],"mappings":"AAyGA,MAAM,CAAC,IAAM,iBAAiB,GAAW,GAAG,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { IPromise } from \"@nevware21/ts-async\";\r\nimport { SendRequestReason } from \"../Enums/SendRequestReason\";\r\nimport { IProcessTelemetryUnloadContext } from \"./IProcessTelemetryContext\";\r\nimport { ITelemetryItem } from \"./ITelemetryItem\";\r\nimport { ITelemetryPlugin } from \"./ITelemetryPlugin\";\r\nimport { ITelemetryUnloadState } from \"./ITelemetryUnloadState\";\r\nimport { IPayloadData } from \"./IXHROverride\";\r\n\r\n/**\r\n * Internal Interface\r\n */\r\nexport interface IInternalOfflineSupport {\r\n\r\n    /**\r\n     * Get current endpoint url\r\n     * @returns endpoint\r\n     */\r\n    getUrl: () => string;\r\n    /**\r\n     * Create payload data\r\n     * @returns IPayloadData\r\n     */\r\n    createPayload: (data: string | Uint8Array) => IPayloadData;\r\n    /**\r\n     * Serialize an item into a string\r\n     * @param input - telemetry item\r\n     * @param convertUndefined - convert undefined to a custom-defined object\r\n     * @returns Serialized string\r\n     */\r\n    serialize?: (input: ITelemetryItem, convertUndefined?: any) => string;\r\n    /**\r\n     * Batch an array of strings into one string\r\n     * @param arr - array of strings\r\n     * @returns a string represent all items in the given array\r\n     */\r\n    batch?: (arr: string[]) => string;\r\n  \r\n    /**\r\n     * If the item should be processed by offline channel\r\n     * @param evt - telemetry item\r\n     * @returns should process or not\r\n     */\r\n    shouldProcess?: (evt: ITelemetryItem) => boolean;\r\n\r\n    /**\r\n     * Create 1ds payload data\r\n     * @param evts - ITelemetryItems\r\n     * @returns IPayloadData\r\n     */\r\n      createOneDSPayload?: (evts: ITelemetryItem[]) => IPayloadData;\r\n\r\n}\r\n\r\n/**\r\n * Provides data transmission capabilities\r\n */\r\nexport interface IChannelControls extends ITelemetryPlugin {\r\n\r\n    /**\r\n     * Pause sending data\r\n     */\r\n    pause?(): void;\r\n\r\n    /**\r\n     * Resume sending data\r\n     */\r\n    resume?(): void;\r\n\r\n    /**\r\n     * Tear down the plugin and remove any hooked value, the plugin should be removed so that it is no longer initialized and\r\n     * therefore could be re-initialized after being torn down. The plugin should ensure that once this has been called any further\r\n     * processTelemetry calls are ignored and it just calls the processNext() with the provided context.\r\n     * @param unloadCtx - This is the context that should be used during unloading.\r\n     * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n     * @returns boolean - true if the plugin has or will call processNext(), this for backward compatibility as previously teardown was synchronous and returned nothing.\r\n     */\r\n    teardown?: (unloadCtx?: IProcessTelemetryUnloadContext, unloadState?: ITelemetryUnloadState) => void | boolean;\r\n\r\n    /**\r\n     * Flush to send data immediately; channel should default to sending data asynchronously. If executing asynchronously and\r\n     * you DO NOT pass a callback function then a [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will be returned which will resolve once the flush is complete. The actual implementation of the `IPromise`\r\n     * will be a native Promise (if supported) or the default as supplied by [ts-async library](https://github.com/nevware21/ts-async)\r\n     * @param isAsync - send data asynchronously when true\r\n     * @param callBack - if specified, notify caller when send is complete, the channel should return true to indicate to the caller that it will be called.\r\n     * If the caller doesn't return true the caller should assume that it may never be called.\r\n     * @param sendReason - specify the reason that you are calling \"flush\" defaults to ManualFlush (1) if not specified\r\n     * @returns - If a callback is provided `true` to indicate that callback will be called after the flush is complete otherwise the caller\r\n     * should assume that any provided callback will never be called, Nothing or if occurring asynchronously a\r\n     * [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html) which will be resolved once the unload is complete,\r\n     * the [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html) will only be returned when no callback is provided\r\n     * and isAsync is true.\r\n     */\r\n    flush?(isAsync: boolean, callBack?: (flushComplete?: boolean) => void, sendReason?: SendRequestReason): boolean | void | IPromise<boolean>;\r\n\r\n    /**\r\n     * Get offline support\r\n     * @returns IInternalOfflineSupport\r\n     */\r\n    getOfflineSupport?: () => IInternalOfflineSupport;\r\n\r\n}\r\n\r\nexport const MinChannelPriorty: number = 100;\r\n"]}