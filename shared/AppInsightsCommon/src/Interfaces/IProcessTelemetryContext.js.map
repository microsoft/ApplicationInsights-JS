{"version":3,"file":"IProcessTelemetryContext.js","sourceRoot":"","sources":["IProcessTelemetryContext.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;AAClC,YAAY,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\n\r\nimport { IConfigDefaults } from \"./Config/IConfigDefaults\";\r\nimport { IAppInsightsCore } from \"./IAppInsightsCore\";\r\nimport { IConfiguration } from \"./IConfiguration\";\r\nimport { IDiagnosticLogger } from \"./IDiagnosticLogger\";\r\nimport { ITelemetryItem } from \"./ITelemetryItem\";\r\nimport { IPlugin, ITelemetryPlugin } from \"./ITelemetryPlugin\";\r\nimport { ITelemetryPluginChain } from \"./ITelemetryPluginChain\";\r\nimport { ITelemetryUnloadState } from \"./ITelemetryUnloadState\";\r\nimport { ITelemetryUpdateState } from \"./ITelemetryUpdateState\";\r\n\r\n// export const enum GetExtCfgMergeType {\r\n//     None = 0,\r\n//     MergeDefaultOnly = 1,\r\n//     MergeDefaultFromRootOrDefault = 2,\r\n// }\r\n\r\nexport interface IBaseProcessingContext {\r\n    /**\r\n     * The current core instance for the request\r\n     */\r\n    core: () => IAppInsightsCore;\r\n\r\n    /**\r\n     * THe current diagnostic logger for the request\r\n     */\r\n    diagLog: () => IDiagnosticLogger;\r\n\r\n    /**\r\n     * Gets the current core config instance\r\n     */\r\n    getCfg: () => IConfiguration;\r\n\r\n    /**\r\n     * Gets the named extension configuration\r\n     * @param identifier - The named extension identifier\r\n     * @param defaultValue - The default value(s) to return if no defined config exists\r\n     * @param rootOnly - If true, only the look for the configuration in the top level and not in the \"extensionConfig\"\r\n     */\r\n    getExtCfg: <T>(identifier: string, defaultValue?: IConfigDefaults<T>, rootOnly?: boolean) => T;\r\n\r\n    /**\r\n     * Gets the named config from either the named identifier extension or core config if neither exist then the\r\n     * default value is returned\r\n     * @param identifier - The named extension identifier\r\n     * @param field - The config field name\r\n     * @param defaultValue - The default value to return if no defined config exists\r\n     */\r\n    getConfig: (identifier: string, field: string, defaultValue?: number | string | boolean | string[] | RegExp[] | Function) => number | string | boolean | string[] | RegExp[] | Function;\r\n\r\n    /**\r\n     * Helper to allow plugins to check and possibly shortcut executing code only\r\n     * required if there is a nextPlugin\r\n     */\r\n    hasNext: () => boolean;\r\n\r\n    /**\r\n     * Returns the next configured plugin proxy\r\n     */\r\n    getNext: () => ITelemetryPluginChain;\r\n\r\n    /**\r\n     * Helper to set the next plugin proxy\r\n     */\r\n    setNext: (nextCtx: ITelemetryPluginChain) => void;\r\n\r\n    /**\r\n     * Synchronously iterate over the context chain running the callback for each plugin, once\r\n     * every plugin has been executed via the callback, any associated onComplete will be called.\r\n     * @param callback - The function call for each plugin in the context chain\r\n     */\r\n    iterate: <T extends ITelemetryPlugin = ITelemetryPlugin>(callback: (plugin: T) => void) => void;\r\n\r\n    /**\r\n     * Set the function to call when the current chain has executed all processNext or unloadNext items.\r\n     * @param onComplete - The onComplete to call\r\n     * @param that - The \"this\" value to use for the onComplete call, if not provided or undefined defaults to the current context\r\n     * @param args - Any additional arguments to pass to the onComplete function\r\n     */\r\n    onComplete: (onComplete: () => void, that?: any, ...args: any[]) => void;\r\n\r\n    /**\r\n     * Create a new context using the core and config from the current instance, returns a new instance of the same type\r\n     * @param plugins - The execution order to process the plugins, if null or not supplied\r\n     *                  then the current execution order will be copied.\r\n     * @param startAt - The plugin to start processing from, if missing from the execution\r\n     *                  order then the next plugin will be NOT set.\r\n     */\r\n    createNew: (plugins?: IPlugin[] | ITelemetryPluginChain, startAt?: IPlugin) => IBaseProcessingContext;\r\n}\r\n\r\n/**\r\n * The current context for the current call to processTelemetry(), used to support sharing the same plugin instance\r\n * between multiple AppInsights instances\r\n */\r\nexport interface IProcessTelemetryContext extends IBaseProcessingContext {\r\n    /**\r\n     * Call back for telemetry processing before it it is sent\r\n     * @param env - This is the current event being reported\r\n     * @returns boolean (true) if there is no more plugins to process otherwise false or undefined (void)\r\n     */\r\n    processNext: (env: ITelemetryItem) => boolean | void;\r\n\r\n    /**\r\n     * Create a new context using the core and config from the current instance, returns a new instance of the same type\r\n     * @param plugins - The execution order to process the plugins, if null or not supplied\r\n     *                  then the current execution order will be copied.\r\n     * @param startAt - The plugin to start processing from, if missing from the execution\r\n     *                  order then the next plugin will be NOT set.\r\n     */\r\n     createNew: (plugins?: IPlugin[] | ITelemetryPluginChain, startAt?: IPlugin) => IProcessTelemetryContext;\r\n}\r\n\r\n/**\r\n * The current context for the current call to teardown() implementations, used to support when plugins are being removed\r\n * or the SDK is being unloaded.\r\n */\r\nexport interface IProcessTelemetryUnloadContext extends IBaseProcessingContext {\r\n\r\n    /**\r\n     * This Plugin has finished unloading, so unload the next one\r\n     * @param uploadState - The state of the unload process\r\n     * @returns boolean (true) if there is no more plugins to process otherwise false or undefined (void)\r\n     */\r\n    processNext: (unloadState: ITelemetryUnloadState) => boolean | void;\r\n\r\n    /**\r\n     * Create a new context using the core and config from the current instance, returns a new instance of the same type\r\n     * @param plugins - The execution order to process the plugins, if null or not supplied\r\n     *                  then the current execution order will be copied.\r\n     * @param startAt - The plugin to start processing from, if missing from the execution\r\n     *                  order then the next plugin will be NOT set.\r\n     */\r\n     createNew: (plugins?: IPlugin[] | ITelemetryPluginChain, startAt?: IPlugin) => IProcessTelemetryUnloadContext;\r\n}\r\n\r\n/**\r\n * The current context for the current call to the plugin update() implementations, used to support the notifications\r\n * for when plugins are added, removed or the configuration was changed.\r\n */\r\nexport interface IProcessTelemetryUpdateContext extends IBaseProcessingContext {\r\n    /**\r\n     * This Plugin has finished unloading, so unload the next one\r\n     * @param updateState - The update State\r\n     * @returns boolean (true) if there is no more plugins to process otherwise false or undefined (void)\r\n     */\r\n    processNext: (updateState: ITelemetryUpdateState) => boolean | void;\r\n\r\n    /**\r\n     * Create a new context using the core and config from the current instance, returns a new instance of the same type\r\n     * @param plugins - The execution order to process the plugins, if null or not supplied\r\n     *                  then the current execution order will be copied.\r\n     * @param startAt - The plugin to start processing from, if missing from the execution\r\n     *                  order then the next plugin will be NOT set.\r\n     */\r\n     createNew: (plugins?: IPlugin[] | ITelemetryPluginChain, startAt?: IPlugin) => IProcessTelemetryUpdateContext;\r\n}\r\n"]}