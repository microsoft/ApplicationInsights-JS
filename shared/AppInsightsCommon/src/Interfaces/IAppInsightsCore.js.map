{"version":3,"file":"IAppInsightsCore.js","sourceRoot":"","sources":["IAppInsightsCore.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { IPromise } from \"@nevware21/ts-async\";\r\nimport { ITimerHandler } from \"@nevware21/ts-utils\";\r\nimport { eActiveStatus } from \"../Enums/InitActiveStatusEnum\";\r\nimport { SendRequestReason } from \"../Enums/SendRequestReason\";\r\nimport { UnloadHandler } from \"../UnloadHandlerContainer\";\r\nimport { WatcherFunction } from \"./Config/IDynamicWatcher\";\r\nimport { IChannelControls } from \"./IChannelControls\";\r\nimport { IConfiguration } from \"./IConfiguration\";\r\nimport { ICookieMgr } from \"./ICookieMgr\";\r\nimport { IDiagnosticLogger } from \"./IDiagnosticLogger\";\r\nimport { IDistributedTraceContext } from \"./IDistributedTraceContext\";\r\nimport { INotificationListener } from \"./INotificationListener\";\r\nimport { INotificationManager } from \"./INotificationManager\";\r\nimport { IPerfManagerProvider } from \"./IPerfManager\";\r\nimport { IProcessTelemetryContext } from \"./IProcessTelemetryContext\";\r\nimport { ITelemetryInitializerHandler, TelemetryInitializerFunction } from \"./ITelemetryInitializers\";\r\nimport { ITelemetryItem } from \"./ITelemetryItem\";\r\nimport { IPlugin, ITelemetryPlugin } from \"./ITelemetryPlugin\";\r\nimport { ITelemetryUnloadState } from \"./ITelemetryUnloadState\";\r\nimport { ILegacyUnloadHook, IUnloadHook } from \"./IUnloadHook\";\r\n\r\n// import { IStatsBeat, IStatsBeatState } from \"./IStatsBeat\";\r\n// import { IStatsMgr } from \"./IStatsMgr\";\r\nexport interface ILoadedPlugin<T extends IPlugin> {\r\n    plugin: T;\r\n\r\n    /**\r\n     * Identifies whether the plugin is enabled and can process events. This is slightly different from isInitialized as the plugin may be initialized but disabled\r\n     * via the setEnabled() or it may be a shared plugin which has had it's teardown function called from another instance..\r\n     * @returns boolean = true if the plugin is in a state where it is operational.\r\n     */\r\n    isEnabled: () => boolean;\r\n\r\n    /**\r\n     * You can optionally enable / disable a plugin from processing events.\r\n     * Setting enabled to true will not necessarily cause the `isEnabled()` to also return true\r\n     * as the plugin must also have been successfully initialized and not had it's `teardown` method called\r\n     * (unless it's also been re-initialized)\r\n     */\r\n    setEnabled: (isEnabled: boolean) => void;\r\n\r\n    remove: (isAsync?: boolean, removeCb?: (removed?: boolean) => void) => void;\r\n}\r\n\r\nexport interface IAppInsightsCore<CfgType extends IConfiguration = IConfiguration> extends IPerfManagerProvider {\r\n\r\n    /*\r\n    * Config object used to initialize AppInsights\r\n    */\r\n    readonly config: CfgType;\r\n\r\n    /**\r\n     * The current logger instance for this instance.\r\n     */\r\n    readonly logger: IDiagnosticLogger;\r\n\r\n    /**\r\n     * An array of the installed plugins that provide a version\r\n     */\r\n    readonly pluginVersionStringArr: string[];\r\n    \r\n    /**\r\n     * The formatted string of the installed plugins that contain a version number\r\n     */\r\n    readonly pluginVersionString: string;\r\n\r\n    // TODO: Add IOTelContextManager type\r\n    /**\r\n     * The root {@link IOTelContextManager} for this instance of the Core.\r\n     */\r\n    readonly context: any;\r\n \r\n    /**\r\n     * Returns a value that indicates whether the instance has already been previously initialized.\r\n     */\r\n    isInitialized?: () => boolean;\r\n\r\n    /*\r\n    * Initialization queue. Contains functions to run when appInsights initializes\r\n    */\r\n    initialize(config: CfgType, extensions: IPlugin[], logger?: IDiagnosticLogger, notificationManager?: INotificationManager): void;\r\n\r\n    /*\r\n    * Get transmission channels for controlling transmission behavior\r\n    */\r\n    getChannels(): IChannelControls[];\r\n\r\n    /*\r\n    * Core track API\r\n    */\r\n    track(telemetryItem: ITelemetryItem): void;\r\n\r\n    /**\r\n     * Get the current notification manager\r\n     */\r\n    getNotifyMgr(): INotificationManager;\r\n\r\n    /**\r\n     * Get the current cookie manager for this instance\r\n     */\r\n    getCookieMgr(): ICookieMgr;\r\n\r\n    /**\r\n     * Set the current cookie manager for this instance\r\n     * @param cookieMgr - The manager, if set to null/undefined will cause the default to be created\r\n     */\r\n    setCookieMgr(cookieMgr: ICookieMgr): void;\r\n\r\n    /**\r\n     * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n     * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n     * called.\r\n     * @param listener - An INotificationListener object.\r\n     */\r\n    addNotificationListener?(listener: INotificationListener): void;\r\n\r\n    /**\r\n     * Removes all instances of the listener.\r\n     * @param listener - INotificationListener to remove.\r\n     */\r\n    removeNotificationListener?(listener: INotificationListener): void;\r\n\r\n    /**\r\n     * Add a telemetry processor to decorate or drop telemetry events.\r\n     * @param telemetryInitializer - The Telemetry Initializer function\r\n     * @returns - A ITelemetryInitializerHandler to enable the initializer to be removed\r\n     */\r\n    addTelemetryInitializer(telemetryInitializer: TelemetryInitializerFunction): ITelemetryInitializerHandler;\r\n\r\n    pollInternalLogs?(eventName?: string): ITimerHandler;\r\n\r\n    // /**\r\n    //  * Get the current stats beat instance for the provided configuration, if enabled.\r\n    //  * @param statsBeatConfig - The configuration to use to create the stats beat instance.\r\n    //  * @returns The stats beat instance or null if not available\r\n    //  */\r\n    // getStatsBeat?(statsBeatConfig: IStatsBeatState): IStatsBeat;\r\n\r\n    // /**\r\n    //  * Set the stats beat manager instance which will be used to create the stats beat instances\r\n    //  * using the provided configuration. This is used to provide greater control over the stats beat\r\n    //  * instance creation and management.\r\n    //  * @param statsMgrCfg - The configuration to use to create the stats beat instance.\r\n    //  * @returns The stats beat instance or null if not available\r\n    //  */\r\n    // setStatsMgr?(statsMgrCfg?: IStatsMgr): void;\r\n\r\n    stopPollingInternalLogs?(): void;\r\n\r\n    /**\r\n     * Return a new instance of the IProcessTelemetryContext for processing events\r\n     */\r\n    getProcessTelContext() : IProcessTelemetryContext;\r\n\r\n    /**\r\n     * Unload and Tear down the SDK and any initialized plugins, after calling this the SDK will be considered\r\n     * to be un-initialized and non-operational, re-initializing the SDK should only be attempted if the previous\r\n     * unload call return `true` stating that all plugins reported that they also unloaded, the recommended\r\n     * approach is to create a new instance and initialize that instance.\r\n     * This is due to possible unexpected side effects caused by plugins not supporting unload / teardown, unable\r\n     * to successfully remove any global references or they may just be completing the unload process asynchronously.\r\n     * If you pass isAsync as `true` (also the default) and DO NOT pass a callback function then an [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will be returned which will resolve once the unload is complete. The actual implementation of the `IPromise`\r\n     * will be a native Promise (if supported) or the default as supplied by [ts-async library](https://github.com/nevware21/ts-async)\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @param unloadComplete - An optional callback that will be called once the unload has completed\r\n     * @param cbTimeout - An optional timeout to wait for any flush operations to complete before proceeding with the\r\n     * unload. Defaults to 5 seconds.\r\n     * @returns Nothing or if occurring asynchronously a [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * which will be resolved once the unload is complete, the [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will only be returned when no callback is provided and isAsync is true\r\n     */\r\n    unload(isAsync?: boolean, unloadComplete?: (unloadState: ITelemetryUnloadState) => void, cbTimeout?: number): void | IPromise<ITelemetryUnloadState>;\r\n\r\n    /**\r\n     * Find and return the (first) plugin with the specified identifier if present\r\n     */\r\n    getPlugin<T extends IPlugin = IPlugin>(pluginIdentifier: string): ILoadedPlugin<T>;\r\n  \r\n    /**\r\n     * Add a new plugin to the installation\r\n     * @param plugin - The new plugin to add\r\n     * @param replaceExisting - should any existing plugin be replaced, default is false\r\n     * @param doAsync - Should the add be performed asynchronously\r\n     * @param addCb - [Optional] callback to call after the plugin has been added\r\n     */\r\n    addPlugin<T extends IPlugin = ITelemetryPlugin>(plugin: T, replaceExisting?: boolean, doAsync?: boolean, addCb?: (added?: boolean) => void): void;\r\n  \r\n    /**\r\n     * Update the configuration used and broadcast the changes to all loaded plugins, this does NOT support updating, adding or removing\r\n     * any the plugins (extensions or channels). It will notify each plugin (if supported) that the configuration has changed but it will\r\n     * not remove or add any new plugins, you need to call addPlugin or getPlugin(identifier).remove();\r\n     * @param newConfig - The new configuration is apply\r\n     * @param mergeExisting - Should the new configuration merge with the existing or just replace it. Default is to merge.\r\n     */\r\n    updateCfg(newConfig: CfgType, mergeExisting?: boolean): void;\r\n\r\n    /**\r\n     * Returns the unique event namespace that should be used when registering events\r\n     */\r\n    evtNamespace(): string;\r\n  \r\n    /**\r\n     * Add a handler that will be called when the SDK is being unloaded\r\n     * @param handler - the handler\r\n     */\r\n    addUnloadCb(handler: UnloadHandler): void;\r\n\r\n    /**\r\n     * Add this hook so that it is automatically removed during unloading\r\n     * @param hooks - The single hook or an array of IInstrumentHook objects\r\n     */\r\n    addUnloadHook(hooks: IUnloadHook | IUnloadHook[] | Iterator<IUnloadHook> | ILegacyUnloadHook | ILegacyUnloadHook[] | Iterator<ILegacyUnloadHook>): void;\r\n\r\n    /**\r\n     * Flush and send any batched / cached data immediately\r\n     * @param async - send data asynchronously when true (defaults to true)\r\n     * @param callBack - if specified, notify caller when send is complete, the channel should return true to indicate to the caller that it will be called.\r\n     * If the caller doesn't return true the caller should assume that it may never be called.\r\n     * @param sendReason - specify the reason that you are calling \"flush\" defaults to ManualFlush (1) if not specified\r\n     * @param cbTimeout - An optional timeout to wait for any flush operations to complete before proceeding with the unload. Defaults to 5 seconds.\r\n     * @returns - true if the callback will be return after the flush is complete otherwise the caller should assume that any provided callback will never be called\r\n     */\r\n    flush(isAsync?: boolean, callBack?: (flushComplete?: boolean) => void, sendReason?: SendRequestReason, cbTimeout?: number): boolean | void;\r\n\r\n    /**\r\n     * Gets the current distributed trace active context for this instance\r\n     * @param createNew - Optional flag to create a new instance if one doesn't currently exist, defaults to true\r\n     */\r\n    getTraceCtx(createNew?: boolean): IDistributedTraceContext | null;\r\n\r\n    /**\r\n     * Sets the current distributed trace context for this instance if available\r\n     */\r\n    setTraceCtx(newTraceCtx: IDistributedTraceContext | null | undefined): void;\r\n\r\n    /**\r\n     * Watches and tracks changes for accesses to the current config, and if the accessed config changes the\r\n     * handler will be recalled.\r\n     * @returns A watcher handler instance that can be used to remove itself when being unloaded\r\n     */\r\n    onCfgChange(handler: WatcherFunction<CfgType>): IUnloadHook;\r\n\r\n    /**\r\n     * Function used to identify the get w parameter used to identify status bit to some channels\r\n     */\r\n    getWParam: () => number;\r\n\r\n    /**\r\n     * Watches and tracks status of initialization process\r\n     * @returns ActiveStatus\r\n     * @since 3.3.0\r\n     * If returned status is active, it means initialization process is completed.\r\n     * If returned status is pending, it means the initialization process is waiting for promieses to be resolved.\r\n     * If returned status is inactive, it means ikey is invalid or can 't get ikey or enpoint url from promsises.\r\n     */\r\n    activeStatus?: () => eActiveStatus | number;\r\n\r\n     /**\r\n     * Set Active Status to pending, which will block the incoming changes until internal promises are resolved\r\n     * @internal Internal use\r\n     * @since 3.3.0\r\n     */\r\n    _setPendingStatus?: () => void;\r\n\r\n}\r\n"]}