{"version":3,"file":"IDynamicWatcher.js","sourceRoot":"","sources":["IDynamicWatcher.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { IConfiguration } from \"../IConfiguration\";\r\nimport { IUnloadHook } from \"../IUnloadHook\";\r\nimport { IConfigDefaults } from \"./IConfigDefaults\";\r\nimport { IDynamicPropertyHandler } from \"./IDynamicPropertyHandler\";\r\n\r\nexport interface IWatchDetails<T = IConfiguration> {\r\n    /**\r\n     * The current config object\r\n     */\r\n    cfg: T;\r\n\r\n    /**\r\n     * Set the value against the provided config/name with the value, the property\r\n     * will be converted to be dynamic (if not already) as long as the provided config\r\n     * is already a tracked dynamic object.\r\n     * @throws TypeError if the provided config is not a monitored dynamic config\r\n     */\r\n    set: <C, V>(theConfig: C, name: string, value: V) => V;\r\n\r\n    /**\r\n     * Set default values for the config if not present.\r\n     * @param theConfig - The configuration object to set default on (if missing)\r\n     * @param defaultValues - The default values to apply to the config\r\n     */\r\n    setDf: <C>(theConfig: C, defaultValues: IConfigDefaults<C>) => C;\r\n\r\n    /**\r\n     * Set this named property of the target as referenced, which will cause any object or array instance\r\n     * to be updated in-place rather than being entirely replaced. All other values will continue to be replaced.\r\n     * @returns The referenced properties current value\r\n     */\r\n    ref: <C, V = any>(target: C, name: string) => V;\r\n\r\n    /**\r\n     * Set this named property of the target as read-only, which will block this single named property from\r\n     * ever being changed for the target instance.\r\n     * This does NOT freeze or seal the instance, it just stops the direct re-assignment of the named property,\r\n     * if the value is a non-primitive (ie. an object or array) it's properties will still be mutable.\r\n     * @returns The referenced properties current value\r\n     */\r\n    rdOnly: <C, V = any>(target: C, name: string) => V;\r\n}\r\n\r\nexport type WatcherFunction<T = IConfiguration> = (details: IWatchDetails<T>) => void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface _WatcherChangeDetails<T = IConfiguration> {\r\n    d: _IDynamicDetail<T>;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface _IDynamicDetail<T = IConfiguration> extends IDynamicPropertyHandler<T> {\r\n\r\n    /**\r\n     * Add the watcher for monitoring changes\r\n     */\r\n    trk: (handler: IWatcherHandler<T>) => void;\r\n\r\n    /**\r\n     * Clear all of the watchers from monitoring changes\r\n     */\r\n    clr: (handler: IWatcherHandler<T>) => void;\r\n}\r\n\r\nexport interface IWatcherHandler<T = IConfiguration> extends IUnloadHook {\r\n    fn: WatcherFunction<T>;\r\n    rm: () => void;\r\n}\r\n"]}