{"version":3,"file":"IConfigDefaults.js","sourceRoot":"","sources":["IConfigDefaults.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { IConfiguration } from \"../IConfiguration\";\r\n\r\n/**\r\n * The type to identify whether the default value should be applied in preference to the provided value.\r\n */\r\nexport type IConfigCheckFn<V> = (value: V) => boolean;\r\n\r\n/**\r\n * The type which identifies the function use to validate the user supplied value\r\n */\r\nexport type IConfigSetFn<T, V> = (value: any, defValue: V, theConfig: T) => V;\r\n\r\n/**\r\n * The default values with a check function\r\n */\r\nexport interface IConfigDefaultCheck<T, V, C = IConfiguration> {\r\n    /**\r\n     * Callback function to check if the user-supplied value is valid, if not the default will be applied\r\n     */\r\n    isVal?: IConfigCheckFn<V>;\r\n\r\n    /**\r\n     * Optional function to allow converting and setting of the default value\r\n     */\r\n    set?: IConfigSetFn<T, V>;\r\n\r\n    /**\r\n     * The default value to apply if the user-supplied value is not valid\r\n     */\r\n    v?: V | IConfigDefaults<V, T>;\r\n\r\n    /**\r\n     *  The default fallback key if the main key is not present, this is the key value from the config\r\n     */\r\n    fb?: keyof T | keyof C | Array<keyof T | keyof C>;\r\n\r\n    /**\r\n     * Use this check to determine the default fallback, default only checked whether the property isDefined,\r\n     * therefore `null`; `\"\"` are considered to be valid values.\r\n     */\r\n    dfVal?: (value: any) => boolean;\r\n\r\n    /**\r\n     * Specify that any provided value should have the default value(s) merged into the value rather than\r\n     * just using either the default of user provided values. Mergeed objects will automatically be marked\r\n     * as referenced.\r\n     */\r\n    mrg?: boolean;\r\n\r\n    /**\r\n     * Set this field of the target as referenced, which will cause any object or array instance\r\n     * to be updated in-place rather than being entirely replaced. All other values will continue to be replaced.\r\n     * This is required for nested default objects to avoid multiple repetitive updates to listeners\r\n     * @returns The referenced properties current value\r\n     */\r\n    ref?: boolean;\r\n\r\n    /**\r\n     * Set this field of the target as read-only, which will block this single named property from\r\n     * ever being changed for the target instance.\r\n     * This does NOT freeze or seal the instance, it just stops the direct re-assignment of the named property,\r\n     * if the value is a non-primitive (ie. an object or array) it's properties will still be mutable.\r\n     * @returns The referenced properties current value\r\n     */\r\n    rdOnly?: boolean;\r\n\r\n    /**\r\n     * Block the value associated with this property from having it's properties / values converted into\r\n     * dynamic properties, this is generally used to block objects or arrays provided by external libraries\r\n     * which may be a plain object with readonly (non-configurable) or const properties.\r\n     */\r\n    blkVal?: boolean;\r\n}\r\n \r\n/**\r\n * The Type definition to define default values to be applied to the config\r\n * The value may be either the direct value or a ConfigDefaultCheck definition\r\n */\r\nexport type IConfigDefaults<T, C = IConfiguration> = {\r\n    [key in keyof T]: T[key] | IConfigDefaultCheck<T, T[key], C>\r\n};\r\n"]}